# 1463 1로 만들기
# https://www.acmicpc.net/problem/1463
def dp(n):
    d = [0] * (n + 1)
    for i in range(2, n + 1):
        # 먼저 이전 값을 가져 온다고 가정한다
        # 1을 빼주는 행동을 한것
        d[i] = d[i - 1] + 1

        # 그 이후 2 와 3을 나눠주면서 -1, 2, 3 세가지 경우를 체크한다
        # 이전값과 비교하여 작은것을 최신화 한다.
        if i % 3 == 0:
            d[i] = min(d[i], d[i//3] + 1)
        if i % 2 == 0:
            d[i] = min(d[i], d[i//2] + 1)
    return d[n]

'''
# 이문제 또한 DP를 활용함
# 이전에 값이 나온것들을 재활용 하는 느낌으로 배열을 만들었지만
# 최소값을 지정해 주는곳에서 틀린것 같다...
# 실패 코드
def dp(n):
    d = [0] * (n + 2)
    # 2랑 3은 어차피 1이므로 먼저 초기 설정
    d[2] = 1
    d[3] = 1

    # 인풋 숫자까지 돌면서 각 값들을 배열에 저장해준다
    for i in range(4, n + 1):
        # 둘다 나누어 떨어지지 않으면 -1
        if i % 3 != 0 and i % 2 != 0:
            d[i] = d[i - 1] + 1
        # 3으로 나누어 떨어졌을때
        elif i % 3 == 0:
            d[i] = d[i//3] + 1
        else:
            # 2로 나누어 떨어지지만 만약 1을 뻈을때 3으로 나누어 떨어지면
            if (i - 1) % 3 == 0:
                d[i] = d[i - 1] + 1
            else:
                d[i] = d[i//2] + 1
    return d[n]
'''

n = int(input())
print(dp(n))
